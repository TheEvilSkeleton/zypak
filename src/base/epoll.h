// Copyright 2019 Endless Mobile, Inc.
// Portions copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#pragma once

#include <sys/epoll.h>

#include <cstdint>
#include <functional>
#include <optional>
#include <unordered_map>

#include "base/unique_fd.h"

namespace zypak {

// A C++-friendly wrapper over the epoll APIs.
class Epoll {
 public:
  Epoll(const Epoll& other) = delete;
  Epoll(Epoll&& other) = default;
  ~Epoll();

  static std::optional<Epoll> Create();

  class Events {
   public:
    enum class Status {
      kNone = 0,
      kRead = 1 << 0,
      kWrite = 1 << 1,
      kReadWrite = (1 << 0) | (1 << 1)
    };

    constexpr Events(Status status) : status_(status) {}

    constexpr Status status() const { return status_; }
    constexpr bool empty() const { return status_ == Status::kNone; }

    constexpr bool contains(Events events) const {
      return (static_cast<int>(status_) & static_cast<int>(events.status_)) != 0;
    }

    constexpr Events operator|(Events other) const {
      return {static_cast<Status>(static_cast<int>(status_) | static_cast<int>(other.status_))};
    }

    Events& operator|=(Events other) {
      *this = *this | other;
      return *this;
    }

   private:
    Status status_;
  };

  class Id {
   private:
    Id(int fd) : fd_(fd) {}
    int fd_;
    friend class Epoll;
  };

  class Trigger {
   public:
    bool Add(std::uint64_t count = 1);

    Id id() const { return id_; }

   private:
    Trigger(Id id) : id_(id) {}
    Id id_;
    friend class Epoll;
  };

  class TriggerReceiver {
   public:
    std::optional<std::uint64_t> GetAndClear();

    Trigger trigger() const { return Trigger(id_); }
    Id id() const { return id_; }

   private:
    TriggerReceiver(Id id) : id_(id) {}
    Id id_;
    friend class Epoll;
  };

  class EventSet {
   public:
    EventSet() : count_(0) {}
    EventSet(const EventSet& other) = delete;
    EventSet(EventSet&& other) = default;

    void Clear() { count_ = 0; }
    std::size_t count() const { return count_; }

   private:
    static constexpr int kMaxEvents = 64;

    epoll_event* data() { return events_.data(); }
    const epoll_event* data() const { return events_.data(); }

    std::array<epoll_event, kMaxEvents> events_;
    std::size_t count_;

    friend class Epoll;
  };

  using Handler = std::function<bool(Epoll*)>;
  using EventsHandler = std::function<bool(Epoll*, Events)>;
  using TriggerHandler = std::function<bool(Epoll*, TriggerReceiver)>;

  // Add a counting trigger that fires (and clears) once the value is at least 1.
  std::optional<TriggerReceiver> AddTrigger(std::uint64_t initial, TriggerHandler func);
  std::optional<TriggerReceiver> AddTrigger(TriggerHandler func) {
    return AddTrigger(0, std::move(func));
  }
  std::optional<TriggerReceiver> AddTriggerOnce(TriggerHandler func);

  // Adds a function that should run in the event loop's thread and environment.
  std::optional<Id> AddTask(Handler func);

  // Add a new timer that fires after the given # of seconds / milliseconds.
  std::optional<Id> AddTimerSec(int seconds, Handler func, bool repeat = false);
  std::optional<Id> AddTimerMs(int ms, Handler func, bool repeat = false);

  // Add a new file descriptor to poll. The file descriptor is not owned by the Epoll instance.
  std::optional<Id> AddFd(int fd, Events events, EventsHandler func);
  std::optional<Id> AddFd(int fd, Handler func) {
    return AddFd(fd, Events::Status::kRead, [func](Epoll* ep, Events events) { return func(ep); });
  }
  // Add a new file descriptor to poll. The file descriptor will be owned by the Epoll instance.
  std::optional<Id> TakeFd(unique_fd fd, Events events, EventsHandler func);
  std::optional<Id> TakeFd(unique_fd fd, Handler func) {
    return TakeFd(std::move(fd), Events::Status::kRead,
                  [func](Epoll* ep, Events events) { return func(ep); });
  }

  // Remove an ID generated by an Add* call.
  bool Remove(Id id);

  bool Wait(EventSet* events);
  bool Dispatch(const EventSet& events);

 private:
  Epoll(unique_fd epfd);

  unique_fd epfd_;

  struct FdData {
    bool owned;
    EventsHandler func;
    bool once = false;
  };

  std::unordered_map<int, FdData> fd_data_;
};

}  // namespace zypak
